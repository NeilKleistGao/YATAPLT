# 导论
## 1.1 计算机科学中的类型
在现代软件工程中，人们常常使用各种**形式方法（formal methods）**来确保系统的行为是符合要求（显式或隐式给出的）的。这些方法中包括了强大的框架，例如霍尔逻辑（Hoare logic），代数规范语言（algebraic specification languages），模态逻辑（modal logics）和指称语义（denotational semantics）。这些框架可以被用来表达非常通用的正确性性质（从而用于验证和测试），但同样也非常笨重，且对程序员有着更高的要求。另一些技术的表示能力会逊于以上提到的这些框架——但刚刚好可以被用于内嵌在编译器、链接器或者程序分析软件中的自动检查。这样就算程序员完全不理解底层的原理，这些技术也能发挥其作用。一个轻量级形式方法的著名例子是模型检查器（model checkers），这是一种可以在如芯片设计或者通信协议这样的有限状态系统中找出错误的工具。另一个例子是越来越受欢迎的运行时监控（run-time monitoring），这是一组可以允许系统动态检测是否有组件没有按照既定要求运行的技术。不过到目前为止，最流行且接受度最高的轻量级形式方法正是类型系统（type systems），即本书所要讨论的内容。
与大型社区共享的许多术语一样（译者注：这里的属于也许指的是类似于“操作系统”这样的，因为这些术语也没法给出一个大家所公认的完美的定义），我们很定义“类型系统”以涵盖编程语言设计者和实现者的非正式用法，不过这个概念也已经足够具体，因而我们还是可以给出一些定义。下面是一个可行的定义：
> 一个类型系统指的是一个易于理解的语法方法，其可以计算出值的种类，并通过对短语进行分类，从而证明某些程序行为不会发生。

这个定义中有些地方需要进行解释。首先，这个定义认为类型系统是程序推理的工具。这里的措辞反映出了本书所讨论的对象是编程语言中的类型系统。更一般地，术语类型系统（或者类型理论）指的是的是逻辑学、数学和哲学中的一个更广泛的概念。这个更广泛的类型系统最早在20世纪初被正式定义，目的是为了避免一些逻辑悖论，如罗素悖论（1902），这几乎动摇了数学体系的根基。在20世纪，类型系统已经成为了标准的逻辑学工具，尤其是在证明论领域（见Gandy, 1976和Hindley, 1997），并慢慢地渗透到哲学和科学领域。这个领域标志性的成果包括罗素的原始分支类型论（original ramified theory of types）(Whitehead and Russell, 1910)，拉姆赛的类型简单理论（Ramsey’s simple theory of types）（1925）——其为丘奇的简单类型lambda演算（simply typed lambda-calculus）的基础（1940）—— Martin-Löf的构造类型论（constructive type theory）（1973, 1984），以及Berardi, Terlouw, and Barendregt的纯粹类型系统（pure type systems）（Berardi, 1988; Terlouw, 1989; Barendregt, 1992）。

即便是在计算机科学领域，类型系统也有两个主要的研究分支。本书所主要关注的是类型系统中更加实用，与编程语言应用相关的那部分。而更加抽象的那部分主要关注于各种纯类型lambda演算和各式逻辑之间的关联，这个关联是通过柯里-霍华德同构（Curry-Howard correspondence）来确立的。相似的概念、记号和技术在两个研究分支中均有应用，不过还是存在着一些方向性上的差异。例如，对有类型lambda演算的研究通常更关注良型计算（well-typed computation）系统的停机问题，而编程语言方面的研究则牺牲了这个性质，转而去探寻诸如递归函数定义这样的特性（译者注：理论研究需要证明良型计算系统是可以停机的，而编程语言的研究不在乎你的代码是否最终会停下来，我们在这个方面主要研究如递归定义这样更实际的问题）。

上述定义中，另一个重要的元素是它强调了根据执行时计算值的属性对句法短语进行分类。一个类型系统可以被认为是程序中句法短语运行时行为的一个静态近似的计算（更进一步地，被赋给句法短语的类型通常是由其子表达式的类型构造而成的）。

术语“静态的”（static）有时会被显式地说明——例如当我们提到“静态类型的编程语言”——我们用这个术语表示编译时的分析，将其与“动态的”（dynamic）或者说“隐式类型的”（latent typing）语言（如Scheme）（Sussman 和 Steele, 1975; Kelsey, Clinger, 和 Rees, 1998; Dybvig, 1996）进行区分。这类语言使用运行时的类型标签来区分堆内存中不同的数据结构。术语“动态类型”（dynamically checked）其实有些用词不当，这里使用“动态检查”会更好，不过前者已经是领域内的标准术语了。(译者注：这里的动态类型所强调的是类型在运行时才进行推断和检查，**而不是一个变量的类型是可以改变的**，后者可见于Python这样的编程语言)

静态类型系统需要是保守的（conservative）：它们能够断言一些不正确的程序行为是不存在的，但是它们无法证明这些行为存在，因此静态类型系统有时需要拒绝一些本来在运行时表现良好的程序（译者注：类型系统可以证明不正确行为存在，这样他们可以放行一些程序；它们同样需要证明这些行为存在，从而拒绝放行这些有问题的代码。但是后者是无法实现的，因为有些问题需要在运行时才能知道，因此对于这类问题，静态类型系统必须**保守地**拒绝它们）。例如这段代码：

```
if <complex test> then 5 else <type error>
```

这句代码会被认为是类型不正确的（ill-typed），即便你能保证`<complex test>`的结果永远为真，因为静态类型系统是不知道这个情况的。在设计类型系统时，如何在保守性和表现能力中进行取舍是一个很重要的问题。为更多的程序确定类型——为程序各个部分更精确地确定类型——是推动这个领域研究的主要动力。

与之相关的一点是，这些类型系统中相对简单直接的分析并不能阻止这些我们不希望产生的行为，他们只能确保良型程序可以避免某些特定的问题。比如，绝大多数的类型系统可以执行静态检查，确保传递给基本算数运算（译者注：这里指的应该是加减乘除这样的运算）的参数一定是数字，函数调用的接收对象总是提供了所需的函数（译者注：这里指的应该是`a.b()`这样的调用中，对象`a`一定拥有函数`b`）等等，但是类型系统无法确保提供给除法的除数是否为0,或者数组下标运算是否越界。

那些可以被编程语言所提供的类型系统消灭的错误行为一般被成为运行时类型错误（run-time type errors）。一定要注意这一系列的行为是每个语言自己的选择：尽管在不同语言之间，公认的运行时类型错误存在大量的重叠，理论上每个语言都有其自己所定义的不允许的行为。类型系统的安全性（safety或soundness）必须具体情况具体分析。

类型分析所检测的错误行为的类型并不局限于调用不存在的函数这种低级错误：类型系统同样可以被用于约束一些高阶的模块化属性，保护用户自定义抽象的完整性。信息隐藏的违反，例如直接访问一些抽象表示的数据，这和将整形数据直接当作指针最终导致设备崩溃一样，都是运行时类型错误。

编译器或链接器通常都包含了类型检查器。这表明了类型检查应该能够自动完成，而不需要与程序员互动或者程序员的介入——即这些步骤必须是计算机所易于处理的。然而，我们依然还是有很大的空间去要求程序员给类型检查器提供一些指引，这些“指引”一般以显式的类型注解（type annotations）提供。通常来说，这些注解一般都非常简单，这样可以使程序更容易读写。但是，理论上，程序满足任意规定的完整证明可以被编码在这些类型注解中，这样类型检查将会变为一个有效的“证明”检查器。像扩展静态检查（Extended Static Checking）（(Detlefs, Leino, Nelson, 和 Saxe, 1998）就是介于类型系统和完整规模的程序检查之间的技术。该技术实现了对某些大类的正确性的完全自动化检查，而仅以来与合理简洁的程序注解。

出于同样的原因，我们也对这些不仅仅局限于理论上可以自动化的方法感兴趣，但这实际上通常伴随着高效的类型检查算法。然而，“什么才是有效的”是一个颇具争议的话题。即便广泛使用的类型系统，比如ML的类型系统（Damas 和 Milner,1982）在极端条件下也会消耗大量的类型检查时间（(Henglein 和 Mairson, 1991）。有些语言甚至还有无法确定的类型检查或类型重构的问题，但对于那些语言，可以使用“在大多数实际感兴趣的情况下”快速停止的算法（例如. Pierce 和 Turner, 2000; Nadathur and Miller, 1988; Pfenning, 1994）。

## 1.2 类型系统好处都有啥
## 1.3 类型系统和语言设计
## 1.4 简单的历史回顾
## 1.5 相关阅读